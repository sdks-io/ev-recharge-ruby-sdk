# shell_ev
#
# This file was automatically generated by APIMATIC v2.0
# ( https://apimatic.io ).

module ShellEv
  # An EVSE can have one or many Connectors. Each Connector will normally have a
  # different socket / cable and only one can be used to charge at a time.
  class ConnectorVO < BaseModel
    SKIP = Object.new
    private_constant :SKIP

    # Internal identifier used to refer to this Connector
    # @return [Integer]
    attr_accessor :uid

    # Identifier of the Evse as given by the Operator, unique for the containing
    # EVSE'
    # @return [String]
    attr_accessor :external_id

    # Identifier of the Evse as given by the Operator, unique for the containing
    # EVSE'
    # @return [ConnectorVOConnectorTypeEnum]
    attr_accessor :connector_type

    # Electrical Properties of the Connector
    # @return [ElectricalProperties]
    attr_accessor :electrical_properties

    # Indicates whether Connector has a fixed cable attached. False by default
    # (not sent in this case)
    # @return [TrueClass | FalseClass]
    attr_accessor :fixed_cable

    # Indicates whether Connector has a fixed cable attached. False by default
    # (not sent in this case)
    # @return [Tariff]
    attr_accessor :tariff

    # ISO8601-compliant UTC datetime of the last update of the Connector’s data
    # @return [String]
    attr_accessor :updated

    # ISO8601-compliant UTC datetime of the last update of the Connector’s data
    # @return [ConnectorVOUpdatedByEnum]
    attr_accessor :updated_by

    # optional  ISO8601-compliant UTC deletion timestamp of the connector
    # @return [String]
    attr_accessor :deleted

    # A mapping from model property names to API property names.
    def self.names
      @_hash = {} if @_hash.nil?
      @_hash['uid'] = 'uid'
      @_hash['external_id'] = 'externalId'
      @_hash['connector_type'] = 'connectorType'
      @_hash['electrical_properties'] = 'electricalProperties'
      @_hash['fixed_cable'] = 'fixedCable'
      @_hash['tariff'] = 'tariff'
      @_hash['updated'] = 'updated'
      @_hash['updated_by'] = 'updatedBy'
      @_hash['deleted'] = 'deleted'
      @_hash
    end

    # An array for optional fields
    def self.optionals
      %w[
        uid
        external_id
        connector_type
        electrical_properties
        fixed_cable
        tariff
        updated
        updated_by
        deleted
      ]
    end

    # An array for nullable fields
    def self.nullables
      []
    end

    def initialize(uid = SKIP, external_id = SKIP, connector_type = SKIP,
                   electrical_properties = SKIP, fixed_cable = SKIP,
                   tariff = SKIP, updated = SKIP, updated_by = SKIP,
                   deleted = SKIP)
      @uid = uid unless uid == SKIP
      @external_id = external_id unless external_id == SKIP
      @connector_type = connector_type unless connector_type == SKIP
      @electrical_properties = electrical_properties unless electrical_properties == SKIP
      @fixed_cable = fixed_cable unless fixed_cable == SKIP
      @tariff = tariff unless tariff == SKIP
      @updated = updated unless updated == SKIP
      @updated_by = updated_by unless updated_by == SKIP
      @deleted = deleted unless deleted == SKIP
    end

    # Creates an instance of the object from a hash.
    def self.from_hash(hash)
      return nil unless hash

      # Extract variables from the hash.
      uid = hash.key?('uid') ? hash['uid'] : SKIP
      external_id = hash.key?('externalId') ? hash['externalId'] : SKIP
      connector_type = hash.key?('connectorType') ? hash['connectorType'] : SKIP
      electrical_properties = ElectricalProperties.from_hash(hash['electricalProperties']) if
        hash['electricalProperties']
      fixed_cable = hash.key?('fixedCable') ? hash['fixedCable'] : SKIP
      tariff = Tariff.from_hash(hash['tariff']) if hash['tariff']
      updated = hash.key?('updated') ? hash['updated'] : SKIP
      updated_by = hash.key?('updatedBy') ? hash['updatedBy'] : SKIP
      deleted = hash.key?('deleted') ? hash['deleted'] : SKIP

      # Create object from extracted values.
      ConnectorVO.new(uid,
                      external_id,
                      connector_type,
                      electrical_properties,
                      fixed_cable,
                      tariff,
                      updated,
                      updated_by,
                      deleted)
    end

    # Provides a human-readable string representation of the object.
    def to_s
      class_name = self.class.name.split('::').last
      "<#{class_name} uid: #{@uid}, external_id: #{@external_id}, connector_type:"\
      " #{@connector_type}, electrical_properties: #{@electrical_properties}, fixed_cable:"\
      " #{@fixed_cable}, tariff: #{@tariff}, updated: #{@updated}, updated_by: #{@updated_by},"\
      " deleted: #{@deleted}>"
    end

    # Provides a debugging-friendly string with detailed object information.
    def inspect
      class_name = self.class.name.split('::').last
      "<#{class_name} uid: #{@uid.inspect}, external_id: #{@external_id.inspect}, connector_type:"\
      " #{@connector_type.inspect}, electrical_properties: #{@electrical_properties.inspect},"\
      " fixed_cable: #{@fixed_cable.inspect}, tariff: #{@tariff.inspect}, updated:"\
      " #{@updated.inspect}, updated_by: #{@updated_by.inspect}, deleted: #{@deleted.inspect}>"
    end
  end
end
